{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useCallback, useEffect, useState } from 'react';\nimport { AuthRequest } from \"./AuthRequest\";\nimport { resolveDiscoveryAsync } from \"./Discovery\";\nexport function useAutoDiscovery(issuerOrDiscovery) {\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      discovery = _useState2[0],\n      setDiscovery = _useState2[1];\n\n  useEffect(function () {\n    resolveDiscoveryAsync(issuerOrDiscovery).then(function (discovery) {\n      setDiscovery(discovery);\n    });\n  }, [issuerOrDiscovery]);\n  return discovery;\n}\nexport function useAuthRequest(config, discovery) {\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      request = _useState4[0],\n      setRequest = _useState4[1];\n\n  var _useState5 = useState(null),\n      _useState6 = _slicedToArray(_useState5, 2),\n      result = _useState6[0],\n      setResult = _useState6[1];\n\n  var promptAsync = useCallback(function _callee() {\n    var options,\n        result,\n        _args = arguments;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n\n            if (!(!discovery || !request)) {\n              _context.next = 3;\n              break;\n            }\n\n            throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n\n          case 3:\n            _context.next = 5;\n            return _regeneratorRuntime.awrap(request == null ? void 0 : request.promptAsync(discovery, options));\n\n          case 5:\n            result = _context.sent;\n            setResult(result);\n            return _context.abrupt(\"return\", result);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, [request == null ? void 0 : request.url, discovery == null ? void 0 : discovery.authorizationEndpoint]);\n  useEffect(function () {\n    if (config && discovery) {\n      var _request = new AuthRequest(config);\n\n      _request.makeAuthUrlAsync(discovery).then(function () {\n        return setRequest(_request);\n      });\n    }\n  }, [discovery == null ? void 0 : discovery.authorizationEndpoint, config.clientId, config.redirectUri, config.prompt, config.scopes.join(','), config.clientSecret, config.codeChallenge, config.state, JSON.stringify(config.extraParams || {}), config.usePKCE]);\n  return [request, result, promptAsync];\n}","map":{"version":3,"sources":["../src/AuthRequestHooks.ts"],"names":[],"mappings":";;AAAA,SAAS,WAAT,EAAsB,SAAtB,EAAiC,QAAjC,QAAiD,OAAjD;AAEA,SAAS,WAAT;AAGA,SAA+C,qBAA/C;AAOA,OAAM,SAAU,gBAAV,CAA2B,iBAA3B,EAA+D;AAAA,kBACjC,QAAQ,CAA2B,IAA3B,CADyB;AAAA;AAAA,MAC5D,SAD4D;AAAA,MACjD,YADiD;;AAGnE,EAAA,SAAS,CAAC,YAAK;AACb,IAAA,qBAAqB,CAAC,iBAAD,CAArB,CAAyC,IAAzC,CAA8C,UAAA,SAAS,EAAG;AACxD,MAAA,YAAY,CAAC,SAAD,CAAZ;AACD,KAFD;AAGD,GAJQ,EAIN,CAAC,iBAAD,CAJM,CAAT;AAMA,SAAO,SAAP;AACD;AAUD,OAAM,SAAU,cAAV,CACJ,MADI,EAEJ,SAFI,EAE+B;AAAA,mBAML,QAAQ,CAAqB,IAArB,CANH;AAAA;AAAA,MAM5B,OAN4B;AAAA,MAMnB,UANmB;;AAAA,mBAOP,QAAQ,CAA2B,IAA3B,CAPD;AAAA;AAAA,MAO5B,MAP4B;AAAA,MAOpB,SAPoB;;AASnC,MAAM,WAAW,GAAG,WAAW,CAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO,YAAA,OAAP,2DAA2C,EAA3C;;AAAA,kBACM,CAAC,SAAD,IAAc,CAAC,OADrB;AAAA;AAAA;AAAA;;AAAA,kBAEU,IAAI,KAAJ,CAAU,uEAAV,CAFV;;AAAA;AAAA;AAAA,6CAIuB,OAJvB,oBAIuB,OAAO,CAAE,WAAT,CAAqB,SAArB,EAAgC,OAAhC,CAJvB;;AAAA;AAIQ,YAAA,MAJR;AAKE,YAAA,SAAS,CAAC,MAAD,CAAT;AALF,6CAMS,MANT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAD6B,EAS7B,CAAC,OAAD,oBAAC,OAAO,CAAE,GAAV,EAAe,SAAf,oBAAe,SAAS,CAAE,qBAA1B,CAT6B,CAA/B;AAYA,EAAA,SAAS,CAAC,YAAK;AACb,QAAI,MAAM,IAAI,SAAd,EAAyB;AACvB,UAAM,QAAO,GAAG,IAAI,WAAJ,CAAgB,MAAhB,CAAhB;;AACA,MAAA,QAAO,CAAC,gBAAR,CAAyB,SAAzB,EAAoC,IAApC,CAAyC;AAAA,eAAM,UAAU,CAAC,QAAD,CAAhB;AAAA,OAAzC;AACD;AACF,GALQ,EAKN,CACD,SADC,oBACD,SAAS,CAAE,qBADV,EAED,MAAM,CAAC,QAFN,EAGD,MAAM,CAAC,WAHN,EAID,MAAM,CAAC,MAJN,EAKD,MAAM,CAAC,MAAP,CAAc,IAAd,CAAmB,GAAnB,CALC,EAMD,MAAM,CAAC,YANN,EAOD,MAAM,CAAC,aAPN,EAQD,MAAM,CAAC,KARN,EASD,IAAI,CAAC,SAAL,CAAe,MAAM,CAAC,WAAP,IAAsB,EAArC,CATC,EAUD,MAAM,CAAC,OAVN,CALM,CAAT;AAkBA,SAAO,CAAC,OAAD,EAAU,MAAV,EAAkB,WAAlB,CAAP;AACD","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\n\nimport { AuthRequest } from './AuthRequest';\nimport { AuthRequestConfig, AuthRequestPromptOptions } from './AuthRequest.types';\nimport { AuthSessionResult } from './AuthSession.types';\nimport { DiscoveryDocument, IssuerOrDiscovery, resolveDiscoveryAsync } from './Discovery';\n\n/**\n * Fetch the discovery document from an OpenID Connect issuer.\n *\n * @param issuerOrDiscovery\n */\nexport function useAutoDiscovery(issuerOrDiscovery: IssuerOrDiscovery): DiscoveryDocument | null {\n  const [discovery, setDiscovery] = useState<DiscoveryDocument | null>(null);\n\n  useEffect(() => {\n    resolveDiscoveryAsync(issuerOrDiscovery).then(discovery => {\n      setDiscovery(discovery);\n    });\n  }, [issuerOrDiscovery]);\n\n  return discovery;\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n * @param config\n * @param discovery\n */\nexport function useAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null\n): [\n  AuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const [request, setRequest] = useState<AuthRequest | null>(null);\n  const [result, setResult] = useState<AuthSessionResult | null>(null);\n\n  const promptAsync = useCallback(\n    async (options: AuthRequestPromptOptions = {}) => {\n      if (!discovery || !request) {\n        throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n      }\n      const result = await request?.promptAsync(discovery, options);\n      setResult(result);\n      return result;\n    },\n    [request?.url, discovery?.authorizationEndpoint]\n  );\n\n  useEffect(() => {\n    if (config && discovery) {\n      const request = new AuthRequest(config);\n      request.makeAuthUrlAsync(discovery).then(() => setRequest(request));\n    }\n  }, [\n    discovery?.authorizationEndpoint,\n    config.clientId,\n    config.redirectUri,\n    config.prompt,\n    config.scopes.join(','),\n    config.clientSecret,\n    config.codeChallenge,\n    config.state,\n    JSON.stringify(config.extraParams || {}),\n    config.usePKCE,\n  ]);\n\n  return [request, result, promptAsync];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}